// ! Note: These tests were generated by AI, although I did go through them to make sure they weren't completely bricked
// ! It is still made by AI, this is because I just wanted to test this quickly and continue working since there is much to do.
// ! If you don't like it, then write your own tests and submit a PR :)

#![allow(unused)]

use crate::instances::{
    InstanstiatedInferredPage, InstanstiatedKeyPage, InstanstiatedObjectBuilder, InstanstiatedRoot,
};
use pdf_struct_traits::*;
use std::any::TypeId;
use std::error::Error;
use std::fmt::{Debug, Display, Formatter};
use std::rc::Rc;

// Test Error type
#[derive(Debug, Clone)]
struct TestError(String);

impl Display for TestError {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "TestError: {}", self.0)
    }
}

impl Error for TestError {}

// Root type
#[derive(Debug, Clone)]
struct TestRoot;

impl Root for TestRoot {}

// Chapter type (child of root, key page, parent of subchapter)
#[derive(Debug, Clone)]
struct Chapter;

impl Parent for Chapter {}

struct Shared;

impl Classify for Chapter {
    type SharedData = Shared;

    fn classify<E>(img: &[u8]) -> ClassificationResult<Shared, E>
    where
        Self: Sized,
        E: Debug + Display + Error,
    {
        ClassificationResult::Confident(0.95, Shared)
    }
}

impl Object for Chapter {
    const CHILDREN: &'static [TypeInformation] = &[SubChapter::TYPE];
    const TYPE: TypeInformation = TypeInformation {
        id: TypeId::of::<Self>(),
        ident: "Chapter",
    };

    type Parent = ();
    type Pair = ();
}

impl KeyPage for Chapter {}
impl Child for Chapter {}

// SubChapter type (child of chapter, key page)
#[derive(Debug, Clone)]
struct SubChapter;
impl Parent for SubChapter {}

impl Classify for SubChapter {
    type SharedData = Shared;
    fn classify<E>(img: &[u8]) -> ClassificationResult<Shared, E>
    where
        Self: Sized,
        E: Debug + Display + Error,
    {
        ClassificationResult::Confident(0.90, Shared)
    }
}

impl Object for SubChapter {
    const CHILDREN: &'static [TypeInformation] = &[Diagram::TYPE, DataTable::TYPE];
    const TYPE: TypeInformation = TypeInformation {
        id: TypeId::of::<Self>(),
        ident: "SubChapter",
    };

    type Parent = Chapter;
    type Pair = ();
}

impl KeyPage for SubChapter {}
impl Child for SubChapter {}

// Diagram type (child of subchapter, inferred page, paired with table, first pair)
#[derive(Debug, Clone)]
struct Diagram;

impl Classify for Diagram {
    type SharedData = Shared;
    fn classify<E>(img: &[u8]) -> ClassificationResult<Shared, E>
    where
        Self: Sized,
        E: Debug + Display + Error,
    {
        ClassificationResult::Probable(0.75, Shared)
    }
}

impl Object for Diagram {
    const CHILDREN: &'static [TypeInformation] = &[];
    const TYPE: TypeInformation = TypeInformation {
        id: TypeId::of::<Self>(),
        ident: "Diagram",
    };

    type Parent = SubChapter;
    type Pair = DataTable;
}

impl InferredPage for Diagram {}
impl Child for Diagram {}

impl PairWith<DataTable> for Diagram {
    const SEQUENCE: PairSequence = PairSequence::First;
    const PATTERNS: &'static [Pattern] = &[]; // Would be populated in real usage
}

// DataTable type (child of subchapter, inferred page, paired with diagram, second pair)
#[derive(Debug, Clone)]
struct DataTable;

impl Classify for DataTable {
    type SharedData = Shared;
    fn classify<E>(img: &[u8]) -> ClassificationResult<Shared, E>
    where
        Self: Sized,
        E: Debug + Display + Error,
    {
        ClassificationResult::Probable(0.80, Shared)
    }
}

impl Object for DataTable {
    const CHILDREN: &'static [TypeInformation] = &[];
    const TYPE: TypeInformation = TypeInformation {
        id: TypeId::of::<Self>(),
        ident: "DataTable",
    };

    type Parent = SubChapter;
    type Pair = Diagram;
}

impl InferredPage for DataTable {}
impl Child for DataTable {}

impl PairWith<Diagram> for DataTable {
    const SEQUENCE: PairSequence = PairSequence::Last;
    const PATTERNS: &'static [Pattern] = &[]; // Would be populated in real usage
}

#[test]
fn test_basic_instantiation() {
    let mut builder = InstanstiatedObjectBuilder::new();

    // Test instantiating each type
    let chapter = builder.build::<Chapter, TestError>();
    assert_eq!(chapter.obj_type.ident, "Chapter");
    assert_eq!(chapter.obj_type.id, TypeId::of::<Chapter>());

    let subchapter = builder.build::<SubChapter, TestError>();
    assert_eq!(subchapter.obj_type.ident, "SubChapter");

    let diagram = builder.build::<Diagram, TestError>();
    assert_eq!(diagram.obj_type.ident, "Diagram");

    let datatable = builder.build::<DataTable, TestError>();
    assert_eq!(datatable.obj_type.ident, "DataTable");
}

#[test]
fn test_parent_relationships() {
    let mut builder = InstanstiatedObjectBuilder::new();

    let chapter = builder.build::<Chapter, TestError>();
    let subchapter = builder.build::<SubChapter, TestError>();
    let diagram = builder.build::<Diagram, TestError>();

    // Check parent relationships
    assert!(chapter.parent.is_none()); // Chapter has no parent (root child)

    assert!(subchapter.parent.is_some());
    assert_eq!(
        subchapter.parent.as_ref().unwrap().obj_type.id,
        TypeId::of::<Chapter>()
    );

    assert!(diagram.parent.is_some());
    assert_eq!(
        diagram.parent.as_ref().unwrap().obj_type.id,
        TypeId::of::<SubChapter>()
    );
}

#[test]
fn test_expected_children() {
    let mut builder = InstanstiatedObjectBuilder::new();

    let chapter = builder.build::<Chapter, TestError>();
    let subchapter = builder.build::<SubChapter, TestError>();

    // Check expected children
    assert_eq!(chapter.expected_children.len(), 1);
    assert_eq!(chapter.expected_children[0].id, TypeId::of::<SubChapter>());

    assert_eq!(subchapter.expected_children.len(), 2);
    let child_types: Vec<TypeId> = subchapter.expected_children.iter().map(|c| c.id).collect();
    assert!(child_types.contains(&TypeId::of::<Diagram>()));
    assert!(child_types.contains(&TypeId::of::<DataTable>()));
}

#[test]
fn test_pair_relationships() {
    let mut builder = InstanstiatedObjectBuilder::new();

    let diagram = builder.build::<Diagram, TestError>();
    let datatable = builder.build::<DataTable, TestError>();

    // Check pair information
    assert!(diagram.pair.is_some());
    let diagram_pair = diagram.get_pair_info().unwrap();
    assert_eq!(diagram_pair.pair_type_info.id, TypeId::of::<DataTable>());
    assert!(matches!(diagram_pair.sequence, PairSequence::First));

    assert!(datatable.pair.is_some());
    let datatable_pair = datatable.get_pair_info().unwrap();
    assert_eq!(datatable_pair.pair_type_info.id, TypeId::of::<Diagram>());
    assert!(matches!(datatable_pair.sequence, PairSequence::Last));
}

#[test]
fn test_add_child_validation() {
    let mut builder = InstanstiatedObjectBuilder::new();

    let mut chapter = (*builder.build::<Chapter, TestError>()).clone();
    let subchapter = builder.build::<SubChapter, TestError>();
    let diagram = builder.build::<Diagram, TestError>();

    // Valid child addition
    assert!(chapter.add_child(subchapter.clone()).is_ok());
    assert_eq!(chapter.children.len(), 1);

    // Invalid child addition (diagram is not a direct child of chapter)
    let result = chapter.add_child(diagram.clone());
    assert!(result.is_err());
    assert!(result.unwrap_err().contains("is not allowed for parent"));

    // Duplicate child addition
    let duplicate_result = chapter.add_child(subchapter.clone());
    assert!(duplicate_result.is_err());
    assert!(duplicate_result.unwrap_err().contains("already exists"));
}

#[test]
fn test_caching() {
    let mut builder = InstanstiatedObjectBuilder::new();

    // Build same type multiple times
    let chapter1 = builder.build::<Chapter, TestError>();
    let chapter2 = builder.build::<Chapter, TestError>();

    // Should be the same object due to caching
    assert!(Rc::ptr_eq(&chapter1, &chapter2));

    // Check cache contains the object
    let cache = builder.get_cache();
    assert!(cache.contains_key(&TypeId::of::<Chapter>()));
    assert_eq!(cache.len(), 1);
}

#[test]
fn test_collect_children_from_cache() {
    let mut builder = InstanstiatedObjectBuilder::new();

    // Build all objects (this populates the cache with parent relationships)
    let chapter = builder.build::<Chapter, TestError>();
    let subchapter = builder.build::<SubChapter, TestError>();
    let diagram = builder.build::<Diagram, TestError>();
    let datatable = builder.build::<DataTable, TestError>();

    // Get mutable reference to test child collection
    let cache = builder.get_cache().clone();
    let mut chapter_mut = (*chapter).clone();
    let mut subchapter_mut = (*subchapter).clone();

    // Collect children from cache
    chapter_mut.collect_children_from_cache(&cache);
    subchapter_mut.collect_children_from_cache(&cache);

    // Chapter should have found SubChapter as child
    assert_eq!(chapter_mut.children.len(), 1);
    assert_eq!(
        chapter_mut.children[0].obj_type.id,
        TypeId::of::<SubChapter>()
    );

    // SubChapter should have found both Diagram and DataTable as children
    assert_eq!(subchapter_mut.children.len(), 2);
    let child_types: Vec<TypeId> = subchapter_mut
        .children
        .iter()
        .map(|c| c.obj_type.id)
        .collect();
    assert!(child_types.contains(&TypeId::of::<Diagram>()));
    assert!(child_types.contains(&TypeId::of::<DataTable>()));
}

#[test]
fn test_instantiated_root() {
    let mut root = InstanstiatedRoot::new();

    // Add root children
    assert!(root.add_root_child::<Chapter, TestError>().is_ok());
    assert_eq!(root.children.len(), 1);

    // Try to add duplicate root child
    let duplicate_result = root.add_root_child::<Chapter, TestError>();
    assert!(duplicate_result.is_err());

    // Connect relationships
    root.connect_relationships();

    // Verify the chapter in root has its children connected
    let chapter = &root.children[0];
    // Note: This test might not work as expected due to Rc immutability
    // In practice, you'd need to manually build the relationships
}

#[test]
fn test_key_page_and_inferred_page_wrappers() {
    let mut builder = InstanstiatedObjectBuilder::new();
    let cache = builder.get_cache_mut();

    // Test KeyPage wrapper
    let key_chapter = InstanstiatedKeyPage::new::<Chapter, TestError>(cache);
    assert_eq!(key_chapter.inner().obj_type.ident, "Chapter");

    let key_subchapter = InstanstiatedKeyPage::new::<SubChapter, TestError>(cache);
    assert_eq!(key_subchapter.inner().obj_type.ident, "SubChapter");

    // Test InferredPage wrapper
    let inferred_diagram = InstanstiatedInferredPage::new::<Diagram, TestError>(cache);
    assert_eq!(inferred_diagram.inner().obj_type.ident, "Diagram");

    let inferred_datatable = InstanstiatedInferredPage::new::<DataTable, TestError>(cache);
    assert_eq!(inferred_datatable.inner().obj_type.ident, "DataTable");
}

#[test]
fn test_can_have_child() {
    let mut builder = InstanstiatedObjectBuilder::new();

    let chapter = builder.build::<Chapter, TestError>();
    let subchapter = builder.build::<SubChapter, TestError>();

    // Chapter can have SubChapter
    assert!(chapter.can_have_child(TypeId::of::<SubChapter>()));
    // Chapter cannot have Diagram directly
    assert!(!chapter.can_have_child(TypeId::of::<Diagram>()));

    // SubChapter can have both Diagram and DataTable
    assert!(subchapter.can_have_child(TypeId::of::<Diagram>()));
    assert!(subchapter.can_have_child(TypeId::of::<DataTable>()));
    // SubChapter cannot have Chapter
    assert!(!subchapter.can_have_child(TypeId::of::<Chapter>()));
}

#[test]
fn test_get_pair_object() {
    let mut builder = InstanstiatedObjectBuilder::new();

    let diagram = builder.build::<Diagram, TestError>();
    let datatable = builder.build::<DataTable, TestError>();

    let cache = builder.get_cache();

    // Test getting pair object from cache
    let diagram_pair_obj = diagram.get_pair_object(cache);
    assert!(diagram_pair_obj.is_some());
    assert_eq!(
        diagram_pair_obj.unwrap().obj_type.id,
        TypeId::of::<DataTable>()
    );

    let datatable_pair_obj = datatable.get_pair_object(cache);
    assert!(datatable_pair_obj.is_some());
    assert_eq!(
        datatable_pair_obj.unwrap().obj_type.id,
        TypeId::of::<Diagram>()
    );
}

#[test]
fn test_build_with_relationships() {
    let mut builder = InstanstiatedObjectBuilder::new();

    // Build objects to populate cache first
    builder.build::<SubChapter, TestError>();
    builder.build::<Diagram, TestError>();
    builder.build::<DataTable, TestError>();

    // Build with relationships should auto-connect children
    let chapter_with_rels = builder.build_with_relationships::<Chapter, TestError>();

    // This test demonstrates the concept, but the current implementation
    // might not work exactly as expected due to the way Rc works
    // You might need to refactor to make relationships more explicit
}

#[test]
fn test_classification_method_storage() {
    let mut builder = InstanstiatedObjectBuilder::new();

    let chapter = builder.build::<Chapter, TestError>();

    // Verify classification method is stored (as Any)
    assert!(chapter.classification_method.as_ref().type_id() != TypeId::of::<()>());
}

#[test]
fn test_print_hierarchy() {
    let mut builder = InstanstiatedObjectBuilder::new();

    // Build all objects to populate the cache and relationships
    builder.build::<Chapter, TestError>();
    builder.build::<SubChapter, TestError>();
    builder.build::<Diagram, TestError>();
    builder.build::<DataTable, TestError>();

    // Create a root and reuse the builder's cache so relationships are preserved
    let mut root = InstanstiatedRoot::new();
    // Move the objects that the builder populated into the root's cache so
    // we operate on the same Rc instances (avoid cloning Rcs which would
    // split ownership and cause Rc::make_mut to clone inner data).
    root.cache = std::mem::take(builder.get_cache_mut());
    // Debug: print cache state before connecting relationships
    println!("Cache before connect:");
    for obj in root.cache.values() {
        println!(
            "- {} (parent: {}) children: {}",
            obj.obj_type.ident,
            obj.parent
                .as_ref()
                .map(|p| p.obj_type.ident)
                .unwrap_or("()"),
            obj.children.len()
        );
    }

    // Connect parent/child relationships based on the cache
    root.connect_relationships();

    // Debug: print cache state after connecting relationships
    println!("Cache after connect:");
    for obj in root.cache.values() {
        println!(
            "- {} (parent: {}) children: {}",
            obj.obj_type.ident,
            obj.parent
                .as_ref()
                .map(|p| p.obj_type.ident)
                .unwrap_or("()"),
            obj.children.len()
        );
    }
    // Populate root.children with objects that have no parent (top-level)
    // after connecting relationships so the Rc instances in `children` point
    // at the cache entries that now have their `children` populated.
    root.children = root
        .cache
        .values()
        .filter(|o| o.parent.is_none())
        .cloned()
        .collect();

    // Helper to print an instantiated object tree
    fn print_obj(obj: &std::rc::Rc<crate::instances::InstanstiatedObject>, indent: usize) {
        for _ in 0..indent {
            print!("  ");
        }
        println!("- {}", obj.obj_type.ident);
        for child in &obj.children {
            print_obj(child, indent + 1);
        }
    }

    println!("Hierarchy:");
    for child in &root.children {
        print_obj(child, 0);
    }

    // Simple assertion to ensure we printed something meaningful
    assert!(!root.children.is_empty());
}
